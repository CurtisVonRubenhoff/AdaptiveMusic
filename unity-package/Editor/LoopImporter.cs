using UnityEngine;
using UnityEditor;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;

namespace AdaptiveMusic.Editor
{
    /// <summary>
    /// Editor utility to import loops extracted by the Audio Loop Extractor
    /// </summary>
    public class LoopImporter : EditorWindow
    {
        private TrackData targetTrack;
        private DefaultAsset loopsFolder;
        private float defaultBPM = 120f;
        private float defaultCrossfade = 0.1f;

        [MenuItem("Tools/Adaptive Music/Loop Importer")]
        public static void ShowWindow()
        {
            GetWindow<LoopImporter>("Loop Importer");
        }

        private void OnGUI()
        {
            GUILayout.Label("Import Extracted Audio Loops", EditorStyles.boldLabel);
            EditorGUILayout.Space();

            EditorGUILayout.HelpBox(
                "This tool imports loops generated by the Audio Loop Extractor Python tool.\n\n" +
                "1. Select or create a TrackData asset\n" +
                "2. Point to the folder containing extracted loop WAV files\n" +
                "3. Click Import to automatically load all loops",
                MessageType.Info
            );

            EditorGUILayout.Space();

            // Track selection
            targetTrack = EditorGUILayout.ObjectField(
                "Target Track",
                targetTrack,
                typeof(TrackData),
                false
            ) as TrackData;

            if (targetTrack == null)
            {
                if (GUILayout.Button("Create New Track"))
                {
                    CreateNewTrack();
                }
            }

            EditorGUILayout.Space();

            // Folder selection
            loopsFolder = EditorGUILayout.ObjectField(
                "Loops Folder",
                loopsFolder,
                typeof(DefaultAsset),
                false
            ) as DefaultAsset;

            EditorGUILayout.Space();

            // Settings
            defaultBPM = EditorGUILayout.FloatField("BPM", defaultBPM);
            defaultCrossfade = EditorGUILayout.FloatField("Default Crossfade", defaultCrossfade);

            EditorGUILayout.Space();

            // Import button
            EditorGUI.BeginDisabledGroup(targetTrack == null || loopsFolder == null);
            if (GUILayout.Button("Import Loops", GUILayout.Height(30)))
            {
                ImportLoops();
            }
            EditorGUI.EndDisabledGroup();

            EditorGUILayout.Space();

            // Parse Report button
            EditorGUI.BeginDisabledGroup(loopsFolder == null);
            if (GUILayout.Button("Parse Report File (Optional)"))
            {
                ParseReportFile();
            }
            EditorGUI.EndDisabledGroup();

            if (targetTrack != null && targetTrack.loops.Count > 0)
            {
                EditorGUILayout.Space();
                EditorGUILayout.LabelField($"Current Track: {targetTrack.loops.Count} loops loaded");
            }
        }

        private void CreateNewTrack()
        {
            string path = EditorUtility.SaveFilePanelInProject(
                "Create New Track",
                "NewTrack",
                "asset",
                "Choose a location to save the TrackData"
            );

            if (!string.IsNullOrEmpty(path))
            {
                TrackData newTrack = CreateInstance<TrackData>();
                newTrack.key = Path.GetFileNameWithoutExtension(path);
                newTrack.displayName = newTrack.key;
                newTrack.bpm = defaultBPM;
                newTrack.defaultCrossfade = defaultCrossfade;

                AssetDatabase.CreateAsset(newTrack, path);
                AssetDatabase.SaveAssets();

                targetTrack = newTrack;
                EditorUtility.DisplayDialog("Success", $"Created new track: {newTrack.displayName}", "OK");
            }
        }

        private void ImportLoops()
        {
            string folderPath = AssetDatabase.GetAssetPath(loopsFolder);
            
            if (string.IsNullOrEmpty(folderPath) || !AssetDatabase.IsValidFolder(folderPath))
            {
                EditorUtility.DisplayDialog("Error", "Invalid folder selected", "OK");
                return;
            }

            // Find all WAV files in the folder
            string[] guids = AssetDatabase.FindAssets("t:AudioClip", new[] { folderPath });
            AudioClip[] clips = guids
                .Select(g => AssetDatabase.LoadAssetAtPath<AudioClip>(AssetDatabase.GUIDToAssetPath(g)))
                .Where(c => c != null && c.name.Contains("_loop_"))
                .OrderBy(c => ExtractLoopIndex(c.name))
                .ToArray();

            if (clips.Length == 0)
            {
                EditorUtility.DisplayDialog("Error", "No loop files found in folder.\n\nLoop files should be named like: trackname_loop_01_10.50s_8.23s.wav", "OK");
                return;
            }

            // Import loops
            targetTrack.bpm = defaultBPM;
            targetTrack.defaultCrossfade = defaultCrossfade;
            targetTrack.LoadLoopsFromClips(clips);

            EditorUtility.SetDirty(targetTrack);
            AssetDatabase.SaveAssets();

            EditorUtility.DisplayDialog(
                "Success",
                $"Imported {clips.Length} loops into track '{targetTrack.displayName}'",
                "OK"
            );
        }

        private void ParseReportFile()
        {
            string folderPath = AssetDatabase.GetAssetPath(loopsFolder);
            string systemPath = Path.GetFullPath(folderPath);

            // Look for report file
            string[] reportFiles = Directory.GetFiles(systemPath, "*_loops_report.txt");
            
            if (reportFiles.Length == 0)
            {
                EditorUtility.DisplayDialog("Info", "No report file found in folder.\n\nReport files are named like: trackname_loops_report.txt", "OK");
                return;
            }

            string reportPath = reportFiles[0];
            string reportContent = File.ReadAllText(reportPath);

            // Parse BPM
            Match bpmMatch = Regex.Match(reportContent, @"Detected Tempo:\s*([\d.]+)\s*BPM");
            if (bpmMatch.Success)
            {
                float.TryParse(bpmMatch.Groups[1].Value, out defaultBPM);
            }

            // Parse recommended crossfade
            Match crossfadeMatch = Regex.Match(reportContent, @"Recommended Crossfade:\s*([\d.]+)s");
            if (crossfadeMatch.Success)
            {
                float.TryParse(crossfadeMatch.Groups[1].Value, out defaultCrossfade);
            }

            // Parse individual loop qualities
            MatchCollection loopMatches = Regex.Matches(reportContent, @"Loop (\d+):.*?Loop Quality:\s*([\d.]+)", RegexOptions.Singleline);
            
            if (targetTrack != null && loopMatches.Count > 0)
            {
                foreach (Match match in loopMatches)
                {
                    int loopIndex = int.Parse(match.Groups[1].Value);
                    float quality = float.Parse(match.Groups[2].Value);

                    LoopData loop = targetTrack.loops.FirstOrDefault(l => l.index == loopIndex);
                    if (loop != null)
                    {
                        loop.quality = quality;
                    }
                }

                EditorUtility.SetDirty(targetTrack);
            }

            EditorUtility.DisplayDialog(
                "Report Parsed",
                $"BPM: {defaultBPM}\nCrossfade: {defaultCrossfade}s\n\n" +
                $"Loop quality scores updated for {loopMatches.Count} loops",
                "OK"
            );
        }

        private int ExtractLoopIndex(string filename)
        {
            // Extract loop number from filename: "trackname_loop_01_..."
            Match match = Regex.Match(filename, @"_loop_(\d+)_");
            if (match.Success)
            {
                int.TryParse(match.Groups[1].Value, out int index);
                return index;
            }
            return 0;
        }
    }
}
